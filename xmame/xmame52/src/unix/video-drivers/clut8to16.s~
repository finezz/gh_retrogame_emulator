# vim:filetype=mips

# several drawing related functions for Allegrex MIPS
# (c) Copyright 2007, Grazvydas "notaz" Ignotas
# All Rights Reserved
# 
# Additional functions added by Slaanesh 2014

.set noreorder # don't reorder any instructions
.set noat      # don't use $at

.text
.align 4

# void clut8to16(unsigned short *dst, unsigned char *src, unsigned int *pal, int count)
#                               $a0                 $a1                $a2       $a3

.global clut8to16

clut8to16:
    srl     $a3, 2
amips_clut_loop8:
    lbu     $t0, 0($a1)           # tried lw here, no improvement noticed
    lbu     $t1, 1($a1)
    lbu     $t2, 2($a1)
    lbu     $t3, 3($a1)
    sll     $t0, 2		   # convert into a int pointer
    sll     $t1, 2
    sll     $t2, 2
    sll     $t3, 2
    addu    $t0, $a2
    addu    $t1, $a2
    addu    $t2, $a2
    addu    $t3, $a2
    lhu     $t0, 0($t0)            # Get 1st pixel
    lhu     $t1, 0($t1)            # Get 2nd pixel
    lhu     $t2, 0($t2)            # Get 3rd pixel
    lhu     $t3, 0($t3)            # Get 4th pixel
#    sll     $t1, 16
#    sll     $t3, 16
#    or      $t0, $t1, $t0
#    or      $t2, $t3, $t2
    ins     $t0, $t1, 16, 16 
    ins     $t2, $t3, 16, 16
    sw      $t0, 0($a0)
    sw      $t2, 4($a0)
    addiu   $a0, 8
    addiu   $a3, -1
    bnez    $a3, amips_clut_loop8
    addiu   $a1, 4
    jr      $ra
    nop

# void clut8to16_16bpp_hack(unsigned short *dst, unsigned char *src, unsigned int *pal, int count)
#                                          $a0                 $a1                $a2       $a3

.global clut8to16_16bpp_hack

clut8to16_16bpp_hack:
    srl     $a3, 3		   # Divide count by 8 pixels (per pass)
amips_clut_loop_hack:
    lhu     $t0, 0($a1)            # each load is 2 pixels, so 8 pixels in one pass
    lhu     $t1, 2($a1)
    lhu     $t2, 4($a1)
    lhu     $t3, 6($a1)
    sll     $t0, 1		   # convert into a int pointer
    sll     $t1, 1
    sll     $t2, 1
    sll     $t3, 1
    addu    $t0, $a2
    addu    $t1, $a2
    addu    $t2, $a2
    addu    $t3, $a2
    lw      $t0, 0($t0)            # Pixels 1+2
    lw      $t1, 0($t1)            # Pixels 3+4
    lw      $t2, 0($t2)            # Pixels 5+6
    lw      $t3, 0($t3)            # Pixels 7+8
    sw      $t0, 0($a0)
    sw      $t1, 4($a0)
    sw      $t2, 8($a0)
    sw      $t3, 12($a0)
    addiu   $a0, 16		    # Increment dst
    addiu   $a3, -1
    bnez    $a3, amips_clut_loop_hack
    addiu   $a1, 8		    # Increment src
    jr      $ra
    nop

# void clut16to16(unsigned short *dst, unsigned short *src, unsigned int *pal, int count)
#                                $a0                  $a1                $a2       $a3

.global clut16to16

clut16to16:
    srl     $a3, 2
amips_clut_loop16:
    lhu     $t0, 0($a1)		    # Load 4 src pens
    lhu     $t1, 2($a1)
    lhu     $t2, 4($a1)
    lhu     $t3, 6($a1)
    sll     $t0, 2		    # Convert to int pointers
    sll     $t1, 2
    sll     $t2, 2
    sll     $t3, 2
    addu    $t0, $a2
    addu    $t1, $a2
    addu    $t2, $a2
    addu    $t3, $a2
    lhu     $t0, 0($t0)		    # Lookup palette
    lhu     $t1, 0($t1)	
    lhu     $t2, 0($t2)
    lhu     $t3, 0($t3)
    ins     $t0, $t1, 16, 16	    # Merge 4 pixels into two words
    ins     $t2, $t3, 16, 16
    sw      $t0, 0($a0)
    sw      $t2, 4($a0)
    addiu   $a0, 8		    # Increment dst
    addiu   $a3, -1
    bnez    $a3, amips_clut_loop16
    addiu   $a1, 8		    # Increment src
    jr      $ra
    nop

.global clut8to16_1_2

clut8to16_1_2:
    srl     $a3, 3
amips_clut_loop2:
    lbu     $t0, 0($a1)           # tried lw here, no improvement noticed
    lbu     $t1, 2($a1)
    lbu     $t2, 4($a1)
    lbu     $t3, 6($a1)
    sll     $t0, 2
    sll     $t1, 2
    sll     $t2, 2
    sll     $t3, 2
    addu    $t0, $a2
    addu    $t1, $a2
    addu    $t2, $a2
    addu    $t3, $a2
    lhu     $t0, 0($t0)            # Get 1st pixel
    lhu     $t1, 0($t1)            # Get 2nd pixel
    lhu     $t2, 0($t2)            # Get 3rd pixel
    lhu     $t3, 0($t3)            # Get 4th pixel
    sll     $t1, 16
    sll     $t3, 16
    or      $t0, $t1, $t0
    or      $t2, $t3, $t2

#    ins     $t0, $t1, 16, 16      # ins rt, rs, pos, size - Insert size bits starting
#    ins     $t2, $t3, 16, 16      #  from the LSB of rs into rt starting at position pos
    sw      $t0, 0($a0)
    sw      $t2, 4($a0)
    addiu   $a0, 8
    addiu   $a3, -1
    bnez    $a3, amips_clut_loop2
    addiu   $a1, 8
    jr      $ra
    nop


#
# Super fast blitter for 1:2 ratio games like Blasteroids, etc.
#
# void clut8to16_1_2_blend(unsigned short *dst, unsigned char *src, unsigned int *pal, int count)
#                                         $a0                 $a1                $a2       $a3

.global clut8to16_1_2_blend

clut8to16_1_2_blend:
    srl     $a3, 2
    li	    $t4, 0x07e0f81f	   # magic 32-bit mask
    lui	    $t5, 0xffff		   
amips_clut_loop3:
    lbu     $t0, 0($a1)
    lbu     $t1, 1($a1)
    lbu     $t2, 2($a1)
    lbu     $t3, 3($a1)
    sll     $t0, 2                 # lookup into unsigned int struct (4x)
    sll     $t1, 2
    sll     $t2, 2
    sll     $t3, 2
    addu    $t0, $a2
    addu    $t1, $a2
    addu    $t2, $a2
    addu    $t3, $a2
    lw      $t0, 0($t0)            # Get 1st expanded pixel from pal
    lw      $t1, 0($t1)            # Get 2nd expanded pixel from pal
    lw      $t2, 0($t2)            # Get 3rd expanded pixel from pal
    lw      $t3, 0($t3)            # Get 4th expanded pixel from pal
    addu    $t1, $t0, $t1	   # Blend pixels
    addu    $t3, $t2, $t3
    srl     $t1, 1		   # Average pixels
    srl     $t3, 1
    and	    $t1, $t1, $t4	   # Apply magic mask
    and	    $t3, $t3, $t4
    addu    $t0, $t1, $0	   # Copy
    addu    $t2, $t3, $0
    srl	    $t0, 16		   # Shift green back into regular position
    sll	    $t2, 16		   # Shift red/blue into upper position
    andi    $t1, $t1, 0xffff	   # Clear upper half
    or	    $t1, $t0, $t1	   # Merge together
    and     $t3, $t3, $t5	   # Clear bottom half
    or	    $t3, $t2, $t3	   # Merge together

    or	    $t0, $t1, $t3	   # Two pixels into one word

#    ins     $t0, $t1, 16, 16      # ins rt, rs, pos, size - Insert size bits starting
#    ins     $t2, $t3, 16, 16      #  from the LSB of rs into rt starting at position pos
    sw      $t0, 0($a0)
    addiu   $a0, 4
    addiu   $a3, -1
    bnez    $a3, amips_clut_loop3
    addiu   $a1, 4
    jr      $ra
    nop

